"""Test the accuracy for each MP-SPDZ origional non-linear functions.
"""
# from nonlinear_config_rep3 import *
import mpc_nonlinear as mn
import Compiler.code.Rep3_code as rc

# different function config.
func_name = str(program.args[1])
func_approx = eval('rc.'+func_name)

min_max_dict = {
    "tanh": (-50, 50),
    "soft_plus": (-20, 50),
    "sigmoid": (-50, 50),
    "elu": (-50, 20),
    "gelu": (-20, 20),
    "selu": (-50, 20),
    "soft_sign": (-50, 50),
    "isru": (-50, 50),
    "snormal_dis": (-10, 10),
    "scauchy_dis": (-40, 40),
    "gamma_dis": (10**(-6), 50.0),
    "chi_square": (0.0, 30),
    "sexp_dis": (0, 10),
    "slog_dis": (0.0001, 40),
    "bs_dis": (1e-6, 30),
}

a, b = min_max_dict[func_name]
  
# system settings.  
if str(program.args[2]) == "ring": 
    program.use_trunc_pr = True
    program.use_split(3)
elif str(program.args[2]) == "field":
    program.use_edabit(True)

sfix.set_precision(48, 96)
# generate test data
N = 10000
step = (b - a) / N
x_list = Array.create_from([sfix(a+step*i) for i in range(N)])

# Test approximation, 1e-3 relative accuracy
general_res = Array.create_from([sfix(0) for _ in range(N)])
@for_range_opt(N)
def _(i):
    general_res[i] = func_approx(x_list[i])

print_ln("General res:")
print_float_prec(14)
print_ln("approximation = %s", general_res.reveal())


# Test benchmark accuracy.
if func_name == "func_sqrt":
    func_name = "sqrt"
if func_name == "func_log":
    func_name = "log"
if func_name == "func_exp":
    func_name = "exp"
    
sfix.set_precision(48)
# generate test data
N = 10000
step = (b - a) / N
x_list = Array.create_from([sfix(a+step*i) for i in range(N)])

benchmark_res = Array.create_from([sfix(0) for _ in range(N)])
# print_ln("Check x_list: %s", x_list.reveal())
@for_range_opt(N)
def _(i):
    global func_name
    benchmark_res[i] = eval("mn."+"mpc_"+func_name)(x_list[i])

print_ln("Benchmark res:")
print_float_prec(14)
print_ln("benchmark = %s", benchmark_res.reveal())